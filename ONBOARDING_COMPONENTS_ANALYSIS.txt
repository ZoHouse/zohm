# Onboarding Components Analysis

## 1. Overview
The onboarding flow for new users (Type 1) is orchestrated by `Onboarding2.tsx` and consists of a sequential process to capture user identity, generate an avatar, and transition to the first quest.

**Flow:** `NicknameStep` -> `AvatarStep` -> `CitizenCard` -> `PortalAnimation` -> `QuestAudio`

---

## 2. Component Breakdown

### üß© `Onboarding2.tsx` (The Orchestrator)
*   **Role**: State manager for the onboarding steps.
*   **State**: `step` ('nickname' | 'avatar' | 'card' | 'portal').
*   **Logic**:
    *   Renders the current step component.
    *   Provides callback handlers (`handleNicknameComplete`, `handleAvatarComplete`, etc.) to advance the state.
    *   Finally calls `onComplete()` which triggers the parent `page.tsx` to show `QuestAudio`.

### üìù `NicknameStep.tsx` (Identity & Creation)
*   **Role**: Collects user details and **creates the user record** in the database.
*   **Inputs**: Nickname, Body Type ('bro'/'bae'), Location (City).
*   **Key Action**: "Get Citizenship" button.
*   **Data Logic**:
    *   Calls `upsertUserFromPrivy` to create the user in Supabase.
    *   **CRITICAL**: This is where the user is first created.
    *   Saves `zo_nickname`, `zo_city`, `zo_body_type` to `localStorage`.
    *   Calls `onNicknameSet` to advance to `AvatarStep`.

### üé® `AvatarStep.tsx` (Profile Enhancement)
*   **Role**: Generates the AI avatar based on the user's choices.
*   **Logic**:
    *   **On Mount**: Reads `localStorage` for nickname/body/city.
    *   **API Call**: Calls `updateProfile` (ZO API) to trigger backend generation.
    *   **Polling**: Polls `getProfile` (ZO API) every 2s until `avatar.image` is ready.
    *   **Fallback**: If timeout (30s) or error, uses a default "Unicorn" avatar.
    *   **Save**: Updates Supabase with the new `pfp` URL.
    *   **Advance**: Automatically moves to `CitizenCard` after success.

---

## 3. Data Flow & Consistency

1.  **User Login (Privy)**: User authenticates via Phone/Wallet. `user.id` (Privy DID) is established.
2.  **NicknameStep**:
    *   User enters details.
    *   **DB Write**: `users` table row created with `id = privyUser.id`.
3.  **AvatarStep**:
    *   **API Write**: Updates ZO Profile (external system).
    *   **DB Update**: Updates `users` table with `pfp`.
4.  **QuestAudio**:
    *   Receives `userId` (Privy DID).
    *   **API Read**: `GET /api/quests/status` checks `completed_quests` table using `userId`.
    *   **API Write**: `POST /api/quests/complete` records completion using `userId`.

## 4. Conclusion
The system is robust because the **User ID is consistent** throughout the entire flow.
*   The user is created in Step 1 (`NicknameStep`).
*   The user is enhanced in Step 2 (`AvatarStep`).
*   The user plays the game in Step 4 (`QuestAudio`).

Even if the client-side `userProfile` state is slightly stale during the transition, the **Database Record** is always up-to-date, and the API calls use the immutable `userId` (Privy DID) to reference it.
